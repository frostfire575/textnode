/**
 * Export Command
 *
 * Export typography configuration as design tokens.
 */

import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import {
  calculateScale,
  resolveAllVariants,
  DEFAULT_VARIANTS,
  DEFAULT_FIXED_SCALE_VALUES,
  type TextnodeConfig,
  type ComputedScale,
  type ComputedVariantStyles,
} from '@textnode/core';

interface ExportOptions {
  format: 'css-vars' | 'tailwind' | 'json' | 'scss';
  output?: string;
  config?: string;
}

/**
 * Generate CSS variables output
 */
function generateCSSVars(
  scale: ComputedScale,
  variants: Record<string, ComputedVariantStyles>,
  config: TextnodeConfig
): string {
  const lines: string[] = [':root {'];

  // Scale values
  lines.push('  /* Type Scale */');
  for (const [key, value] of Object.entries(scale)) {
    const cssValue = typeof value === 'number' ? `${value}px` : value;
    lines.push(`  --text-${key}: ${cssValue};`);
  }
  lines.push('');

  // Font families
  lines.push('  /* Font Families */');
  for (const [key, font] of Object.entries(config.fonts)) {
    const fallback = font.fallback?.font || 'sans-serif';
    lines.push(`  --font-${key}: '${font.name}', '${font.name} Fallback', ${fallback};`);
  }
  lines.push('');

  // Variant styles as CSS custom properties
  lines.push('  /* Variant Styles */');
  for (const [key, styles] of Object.entries(variants)) {
    if (styles.fontSize) {
      lines.push(`  --variant-${key}-size: ${styles.fontSize};`);
    }
    if (styles.fontWeight) {
      lines.push(`  --variant-${key}-weight: ${styles.fontWeight};`);
    }
    if (styles.lineHeight) {
      lines.push(`  --variant-${key}-leading: ${styles.lineHeight};`);
    }
  }

  lines.push('}');
  return lines.join('\n');
}

/**
 * Generate Tailwind config output
 */
function generateTailwind(
  scale: ComputedScale,
  config: TextnodeConfig
): string {
  const fontFamily: Record<string, string[]> = {};
  const fontSize: Record<string, string> = {};

  // Font families
  for (const [key, font] of Object.entries(config.fonts)) {
    const fallback = font.fallback?.font || 'sans-serif';
    fontFamily[key] = [font.name, `${font.name} Fallback`, fallback];
  }

  // Font sizes
  for (const [key, value] of Object.entries(scale)) {
    fontSize[key] = typeof value === 'number' ? `${value / 16}rem` : String(value);
  }

  const output = {
    theme: {
      extend: {
        fontFamily,
        fontSize,
      },
    },
  };

  return `// Tailwind CSS configuration generated by textnode
// Add this to your tailwind.config.js

module.exports = ${JSON.stringify(output, null, 2)};
`;
}

/**
 * Generate JSON output
 */
function generateJSON(
  scale: ComputedScale,
  variants: Record<string, ComputedVariantStyles>,
  config: TextnodeConfig
): string {
  const output = {
    scale: Object.fromEntries(
      Object.entries(scale).map(([key, value]) => [
        key,
        typeof value === 'number' ? `${value}px` : value,
      ])
    ),
    fonts: Object.fromEntries(
      Object.entries(config.fonts).map(([key, font]) => [
        key,
        {
          name: font.name,
          fallback: font.fallback?.font,
          variable: font.variable,
        },
      ])
    ),
    variants,
  };

  return JSON.stringify(output, null, 2);
}

/**
 * Generate SCSS variables output
 */
function generateSCSS(
  scale: ComputedScale,
  _variants: Record<string, ComputedVariantStyles>,
  config: TextnodeConfig
): string {
  const lines: string[] = ['// Generated by textnode', ''];

  // Scale values
  lines.push('// Type Scale');
  for (const [key, value] of Object.entries(scale)) {
    const cssValue = typeof value === 'number' ? `${value}px` : value;
    lines.push(`$text-${key}: ${cssValue};`);
  }
  lines.push('');

  // Scale map
  lines.push('$text-scale: (');
  for (const [key, value] of Object.entries(scale)) {
    const cssValue = typeof value === 'number' ? `${value}px` : value;
    lines.push(`  '${key}': ${cssValue},`);
  }
  lines.push(');');
  lines.push('');

  // Font families
  lines.push('// Font Families');
  for (const [key, font] of Object.entries(config.fonts)) {
    const fallback = font.fallback?.font || 'sans-serif';
    lines.push(`$font-${key}: '${font.name}', '${font.name} Fallback', ${fallback};`);
  }
  lines.push('');

  // Font map
  lines.push('$fonts: (');
  for (const key of Object.keys(config.fonts)) {
    lines.push(`  '${key}': $font-${key},`);
  }
  lines.push(');');

  return lines.join('\n');
}

/**
 * Try to load configuration from file
 */
function loadConfig(configPath?: string): TextnodeConfig {
  // Default config for demo
  const defaultConfig: TextnodeConfig = {
    fonts: {
      heading: {
        name: 'Heading Font',
        files: { 400: '', 700: '' },
        fallback: { font: 'Arial' },
      },
      body: {
        name: 'Body Font',
        files: { 400: '' },
        fallback: { font: 'system-ui' },
      },
    },
    scale: {
      type: 'fixed',
      values: DEFAULT_FIXED_SCALE_VALUES,
    },
    variants: DEFAULT_VARIANTS,
  };

  if (configPath) {
    try {
      const fullPath = path.resolve(configPath);
      // In production, use proper config loading
      // For now, return default
      console.log(chalk.yellow(`Note: Config loading from ${fullPath} not yet implemented.`));
      console.log(chalk.yellow('Using default configuration for demo.'));
      console.log('');
    } catch {
      // Ignore errors, use default
    }
  }

  return defaultConfig;
}

/**
 * Export command handler
 */
export async function exportCommand(options: ExportOptions): Promise<void> {
  const spinner = ora('Generating design tokens...').start();

  try {
    // Load configuration
    const config = loadConfig(options.config);

    // Calculate scale
    const scale = calculateScale(config.scale);

    // Resolve variants
    const variants = resolveAllVariants(
      config.variants || DEFAULT_VARIANTS,
      scale,
      config.fonts
    );

    // Generate output based on format
    let output: string;
    let extension: string;

    switch (options.format) {
      case 'css-vars':
        output = generateCSSVars(scale, variants, config);
        extension = '.css';
        break;

      case 'tailwind':
        output = generateTailwind(scale, config);
        extension = '.js';
        break;

      case 'json':
        output = generateJSON(scale, variants, config);
        extension = '.json';
        break;

      case 'scss':
        output = generateSCSS(scale, variants, config);
        extension = '.scss';
        break;

      default:
        throw new Error(`Unknown format: ${options.format}`);
    }

    spinner.succeed('Design tokens generated!');
    console.log('');

    // Output to file or stdout
    if (options.output) {
      const outputPath = options.output.endsWith(extension)
        ? options.output
        : `${options.output}${extension}`;

      fs.writeFileSync(outputPath, output, 'utf-8');
      console.log(chalk.green('Written to:'), outputPath);
    } else {
      console.log(chalk.bold(`Output (${options.format}):`));
      console.log('');
      console.log(output);
    }

  } catch (error) {
    spinner.fail(chalk.red('Failed to generate design tokens'));
    console.error(error);
    process.exit(1);
  }
}
